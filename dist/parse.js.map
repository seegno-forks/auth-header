{"version":3,"sources":["../src/parse.js"],"names":["body","normalize","prev","_cur","cur","charAt","trim","Array","isArray","concat","parseProperties","scheme","string","res","token","params","exec","str","start","indexOf","substr"],"mappings":";;;;;;AAAA;;;;AACA;;;;AAEA;AACA,IAAMA,OAAO,oIAAb,C,CAAmJ;;AAEnJ,IAAMC,YAAY,SAAZA,SAAY,CAACC,IAAD,EAAOC,IAAP,EAAgB;AAChC;AACA,MAAMC,MAAMD,KAAKE,MAAL,CAAY,CAAZ,MAAmB,GAAnB,GAAyB,mBAAQF,IAAR,CAAzB,GAAyCA,KAAKG,IAAL,EAArD;;AAEA;AACA,MAAIC,MAAMC,OAAN,CAAcN,IAAd,CAAJ,EAAyB;AACvB,WAAOA,KAAKO,MAAL,CAAYL,GAAZ,CAAP;AACD,GAFD,MAEO,IAAIF,IAAJ,EAAU;AACf,WAAO,CAACA,IAAD,EAAOE,GAAP,CAAP;AACD;AACD,SAAOA,GAAP;AACD,CAXD;;AAaA,IAAMM,kBAAkB,SAAlBA,eAAkB,CAACC,MAAD,EAASC,MAAT,EAAoB;AAC1C,MAAIC,MAAM,IAAV;AACA,MAAIC,QAAQ,IAAZ;AACA,MAAMC,SAAS,EAAf;;AAEA,SAAO,CAACF,MAAMb,KAAKgB,IAAL,CAAUJ,MAAV,CAAP,MAA8B,IAArC,EAA2C;AACzC,QAAIC,IAAI,CAAJ,CAAJ,EAAY;AACVE,aAAOF,IAAI,CAAJ,CAAP,IAAiBZ,UAAUc,OAAOF,IAAI,CAAJ,CAAP,CAAV,EAA0BA,IAAI,CAAJ,CAA1B,CAAjB;AACD,KAFD,MAEO;AACLC,cAAQb,UAAUa,KAAV,EAAiBD,IAAI,CAAJ,CAAjB,CAAR;AACD;AACF;;AAED,SAAO,EAACF,cAAD,EAASI,cAAT,EAAiBD,YAAjB,EAAP;AACD,CAdD;;kBAgBe,UAACG,GAAD,EAAS;AACtB,MAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;AAC3B,UAAM,iCAAuB,gCAAvB,CAAN;AACD;;AAED,MAAMC,QAAQD,IAAIE,OAAJ,CAAY,GAAZ,CAAd;AACA,MAAMR,SAASM,IAAIG,MAAJ,CAAW,CAAX,EAAcF,KAAd,CAAf;;AAEA,MAAI,CAAC,oBAASP,MAAT,CAAL,EAAuB;AACrB,UAAM,qDAAyCA,MAAzC,CAAN;AACD;;AAED,SAAOD,gBAAgBC,MAAhB,EAAwBM,IAAIG,MAAJ,CAAWF,KAAX,CAAxB,CAAP;AACD,C","file":"parse.js","sourcesContent":["import InvalidHeaderError from './invalid-header-error';\nimport {isScheme, unquote} from './util';\n\n// lol dis\nconst body = /((?:[a-zA-Z0-9._~+\\/-]+=*(?:\\s+|$))|[^\\u0000-\\u001F\\u007F()<>@,;:\\\\\"/?={}\\[\\]\\u0020\\u0009]+)(?:=([^\\\\\"=\\s,]+|\"(?:[^\"\\\\]|\\\\.)*\"))?/g; // eslint-disable-line\n\nconst normalize = (prev, _cur) => {\n  // Fixup quoted strings and tokens with spaces around them\n  const cur = _cur.charAt(0) === '\"' ? unquote(_cur) : _cur.trim();\n\n  // Marshal\n  if (Array.isArray(prev)) {\n    return prev.concat(cur);\n  } else if (prev) {\n    return [prev, cur];\n  }\n  return cur;\n};\n\nconst parseProperties = (scheme, string) => {\n  let res = null;\n  let token = null;\n  const params = { };\n\n  while ((res = body.exec(string)) !== null) {\n    if (res[2]) {\n      params[res[1]] = normalize(params[res[1]], res[2]);\n    } else {\n      token = normalize(token, res[1]);\n    }\n  }\n\n  return {scheme, params, token};\n};\n\nexport default (str) => {\n  if (typeof str !== 'string') {\n    throw new InvalidHeaderError('Header value must be a string.');\n  }\n\n  const start = str.indexOf(' ');\n  const scheme = str.substr(0, start);\n\n  if (!isScheme(scheme)) {\n    throw new InvalidHeaderError(`Invalid scheme ${scheme}`);\n  }\n\n  return parseProperties(scheme, str.substr(start));\n};\n"]}